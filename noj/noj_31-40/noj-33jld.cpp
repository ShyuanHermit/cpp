/*************************************************************************
    > File Name: /home/lvshy/cpp/noj/noj_31-40/noj-33/noj-33jld.cpp
    > Author: lvshy
    > Mail: Shyuan231026nwpu@outlook.com 
    > Created Time: Sat Nov 11 17:37:30 2023
 ************************************************************************/

/*首先，这个问题，我考虑过很久，有想过数字规律（特征数列），有想过坐标/斜率 ；
最后发现落脚在了斜率上，这很有趣，或者说，是落脚在了找最简真分数上。
由于0，1，无穷在N=2是就已经解决，通式可以写为最简真分数数目乘二。所以，我们 要做的就是找到最简的真分数。
很简单的，我们就可以想到取模，找到他们是不是互质的。
之前的欧几里得算法在找最大公因数上近乎无敌，但是，简单的判断，只需取模·，效 果最好。
由于在函数这一章，我们可以考虑函数，毕竟在大部分情况下，姜老登还没有那么的阴险。
及写出一个快速找出质数。要说快速，我能想到的就是，我们可以通过质数一步一步验证。
既然要验证，我们可以考虑迭代的方法。既是继承之前的质数。注意我们会省去很多时间--除了遇到质数。
考虑一下，如果是对于质数相乘的情况，会不会和分解后的指数有一些关系？答案是肯定的，分解之后，
再次应对质数。是不是很有迭代的味道？又很有数论的味道？
当然，也许姜老登没有想有多？我们可以在另一个附件中试一试。我打算命名为noj-33jld.cpp。

——————————————————————————————————————————————————————————————————————————————————---------

把这个题看成是对于斜率的处理，那么我们只需要是做出一个验证质数的程序，
然而这才是第一步，显然在处理大量数据时这是不可行的。
如果我们有一个更高效地找出质数的方法就好了。

1.思考，每次增加的人数都是可感的，简单来说就是每次先增加2N-1个人。
对于这些人的处理，如何来简化?

2.从总体上看，是具有一定规律的，如果对于整个N*N的方阵来说，有没有可以简化的 地方，这很重要。

———————————————————————————————————————————————————————————————————————————————————————————

对于第一种，增加的都可以认为是以N为分母的分数（不论真假）。那么显然优化是不 可行的，
因为我们还是得通过枚举来完成，且越来越复杂，一个操作数线性增长的过程，雪球会越滚越大，
因为看起来一阶导是个线性，可以拟合二次函数了。

对于第二种，我们就要从整体上考虑了。
唔，面对万恶的姜老登，我们怎么去思考呢？从整体上怎么去优化呢？
*/
#include<bits/stdc++.h>

using namespace std;

int gcd(int a,int b){
	return b>0?gcd(b,a%b):a;
}
int prime(int i){
	int j=1,ans=0;
	while(j<=i/2){if (gcd(i,j)==1){ans+=4;}
		j++;
	}
	return ans;

};

int main(){

	int N,i;
	long long ans;

	cin>>N;

	if(N==2){i=2,ans=3;}else
	{i=3,ans=5;}

	while(i<N){
	
	ans+=prime(i);
	i++;
	}

	cout<<ans;
return 0;
	}

/*我们所需要的是写出一个判断互质的函数。由于质数的英文是prime number；命名我们的函数为prime.
考虑清楚我们的操作对象。显然，首先应该有一个输入值，有一个内变量。
运算逻辑是输入一个i，作为分母，然后有一个初始化的j来对函数进行操作。j的取值在1~i之间操作。
由于对应，所以每次都乘两个（只有1在题中出现一次。）
所以，非常明确，在函数中的值返回后加上ans的前s值就可以了。
问题在于检验互质，最简单的办法就是最大公因数为1.再次使用欧几里得算法，但是这样太慢了。
由于这个程序就是在试做，所以慢就慢些咯。
阿基米德洗澡时发现了浮力，我们发现了这个程序是可被再次优化的*/
