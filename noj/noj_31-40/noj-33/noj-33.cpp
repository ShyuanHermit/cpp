/*************************************************************************
    > File Name: /home/lvshy/cpp/noj/noj_31-40/noj-33.cpp
    > Author: lvshy
    > Mail: Shyuan231026nwpu@outlook.com
    > Created Time: Sat Nov 11 15:34:33 2023
 ************************************************************************/

#include<bits/stdc++.h>

using namespace std;

int main(){

        int N,i=1;
        cin>>N;





return 0;

}
/*首先，这个问题，我考虑过很久，有想过数字规律（特征数列），有想过坐标/斜率；
最后发现落脚在了斜率上，这很有趣，或者说，是落脚在了找最简真分数上。
由于0，1，无穷在N=2是就已经解决，通式可以写为最简真分数数目乘二。所以，我们要做的就是找到最简的真分数。
很简单的，我们就可以想到取模，找到他们是不是互质的。
之前的欧几里得算法在找最大公因数上近乎无敌，但是，简单的判断，只需取模·，效果最好。
由于在函数这一章，我们可以考虑函数，毕竟在大部分情况下，姜老登还没有那么的阴险。
及写出一个快速找出质数。要说快速，我能想到的就是，我们可以通过质数一步一步验证。
既然要验证，我们可以考虑迭代的方法。既是继承之前的质数。注意我们会省去很多时间--除了遇到质数。
考虑一下，如果是对于质数相乘的情况，会不会和分解后的指数有一些关系？答案是肯定的，分解之后，
再次应对质数。是不是很有迭代的味道？又很有数论的味道？
当然，也许姜老登没有想有多？我们可以在另一个附件中试一试。我打算命名为noj-33jld.cpp。

——————————————————————————————————————————————————————————————————————————————————---------

把这个题看成是对于斜率的处理，那么我们只需要是做出一个验证质数的程序，
然而这才是第一步，显然在处理大量数据时这是不可行的。
如果我们有一个更高效地找出质数的方法就好了。

1.思考，每次增加的人数都是可感的，简单来说就是每次先增加2N-1个人。
对于这些人的处理，如何来简化?

2.从总体上看，是具有一定规律的，如果对于整个N*N的方阵来说，有没有可以简化的地方，这很重要。

———————————————————————————————————————————————————————————————————————————————————————————

对于第一种，增加的都可以认为是以N为分母的分数（不论真假）。那么显然优化是不可行的，
因为我们还是得通过枚举来完成，且越来越复杂，一个操作数线性增长的过程，雪球会越滚越大，
因为看起来一阶导是个线性，可以拟合二次函数了。

对于第二种，我们就要从整体上考虑了。
唔，面对万恶的姜老登，我们怎么去思考呢？从整体上怎么去优化呢？
*/
