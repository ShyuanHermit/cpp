/*************************************************************************
    > File Name: /home/lvshy/cpp/noj/noj_21-30/noj-24.cpp
    > Author: lvshy
    > Mail: shyuan051019@outlook.com 
    > Created Time: Tue Oct 31 13:26:40 2023
 ************************************************************************/

#include <bits/stdc++.h>

using namespace std;

int main(){
        long long k,n=2,t,s,i;

        do{
	    cin>>k;
        }while(!(k>=2));

        do{
               s=n;t=1;i=0;

                while(s>0){
                        t=t*s--;
                        i++;}

                n++;
			}while(t%k!=0);

                cout<<i;

                return 0;
        }
/*
思考这个问题会发现，我们报错的根本原因是我们的程序会溢出，即使是使用long long也会发生溢出的问题。
所以我们来思考这样一件事情，为什么会溢出。
显然，阶乘运算本来就是一个增长很快的运算，long long的数据范围只到了pow(2,64)，事实上这并不很大，我们不难发现，
70的阶乘为：
119785716699698917960727837216890987364589381425464258575553
62864628009582789845319680000000000000000 ,这个数据远远的超过了我们的所需。
所以这个思路是错的。
为什么说不可行？
很简单，在没有改变思路的情况下，相差的数量级太大了。
我们极端一些，用尽一切办法缩小内存，所能容纳的数仍然是很小的。
但是反过来想，题目本来要求我们输出的就是阶乘的给定数，这个数就是不大的。
即是说，在不影响输出值的前提下，我们应该更换一种思路--分步运算。
于是，题目等价为：进行多步运算，保证他的每一步没有溢出。
最大的问题来了，这样一种求阶乘的方式，怎么去分步呢？
那就是，假如一个数是可以作为另一个数的阶乘的因数，那么，我们的每一个引数是可以对应的
而分解彻底的因数都是素数，或者说，任何数可以被仅以素数的形式表示。
那么，用素数来分解呢？
但是，这个思路也被否定了，因为一定会超时，分解为素数的方式太过于麻烦了。
到这里我都想骂死姜老登了，啥都想不出来了。
我们目前的矛盾很明确，要么会溢出，由于操作步骤少，单次运算的运算量很大；
要么，会超时，简单而又繁琐的运算会使得计算机d运行时间过长。
那怎么办呢？本着姜老登本人数学程度不如我的态度，我们试图寻找他是不是试图班门弄斧。
（这是他经常干的事情，看看前面的欧几里得算法你就明白了。）
所以，我们来看看怎么去寻找一个数的阶乘，使它可以被目标数整除。
